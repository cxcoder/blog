JVM 通过GC管理对象内存的分配和回收，为了提高GC的效率，Hotspot JVM 采用分代垃圾回收算法，在jdk8中堆分成以下几个部分：

- *Young Generation*：年轻代，此区域对象的生命周期比较短，一次Minor GC就能回收大部分对象，年轻代又进一步分为Eden和Survivor，Survivor又分为两个大小相等的From和To区域。

- *Old Generation*：老年代，此区域对象生命周期比较长。


## 内存分配

对象实例首先在 Eden 区分配，为了分配效率，JVM 采用的是一种 *bump-the-pointer* 的**线性分配**方法。分配时一般都有大块连续内存可用，此方法就是检查剩余内存是否足够，给对象分配内存，然后更新指针偏移量和初始化对象。


线性分配效率固然高，但对多线程程序来说，分配内存的操作必须是线程安全的。可以使用全局锁但会影响性能，Hotspot JVM 采用的是一种 *Thread-Local Allocation Buffers (TLABs)* 的方法，为每个线程分配一个缓冲区，当TLAB满了，再加锁去申请，在线程内部就能使用*bump-the-pointer*，进而提高分配的吞吐量。


分配内存时，一些大对象有可能直接在老年代分配，在年轻代经过几轮Minor GC存活的对象，会被提升到老年代。


## 垃圾收集

内存回收主要考虑以下两个问题：

- **如何判断对象可被回收**，主要有以下几种策略：

 - *Tracing GC*，跟踪收集，也叫**可达性分析算法**，其思想是从某些**根对象引用**出发总能找到一个到一组存活对象的引用链。
 - *Reference counting*，**引用计数法**，不能解决循环引用的问题。
 - *Escape analysis*，**逃逸分析**，可以将堆分配转为栈分配，减轻GC压力，动态编译优化，自JDK 6u23开始支持。

JVM 采用 Tracing GC 管理堆中的对象，那么堆外的**对象引用**就可以作为GC root：

- 栈帧中局部变量或方法参数的对象引用
- 类引用类型静态成员变量
- JNI 本地方法局部变量，参数和JNI 全局引用

需要注意GC root是一组**对象引用**而不是引用对象。


- **采用何种方式进行回收**

