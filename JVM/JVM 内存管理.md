JVM 通过 *垃圾收集-GC* 自动管理内存，主要对堆中对象内存的分配和回收。为了便于整理内存碎片，JVM 采用**分代垃圾收集器**，基于对象不同生命周期，将堆分成不同的内存区域，分别采用不同的垃圾收集算法。JVM 堆可简单认为由以下两部分组成：

- *Young Generation*：年轻代，由*Eden*和两个相等的*Survivor*空间组成，其中一个Survivor始终为空，用来复制Minor GC后在Eden和另一个Survivor存活的对象。
- *Old Generation*：老年代，对象生命周期比较长。


## 内存回收

内存回收主要考虑两个问题：

- **如何判断对象可被回收**，判断策略：
 - *Tracing GC*，跟踪收集，也叫**可达性分析算法**，其思想是从某些**根对象引用(GC roots)**出发总能找到一个到一组存活对象的引用链。
 - *Reference counting*，**引用计数法**，不能解决循环引用。
 - *Escape analysis*，**逃逸分析**，可以将堆分配转为栈分配，动态编译优化，减轻GC压力。


- **采用何种方式进行回收**，垃圾收集算法：
 - *Copying*，复制，将存活对象从一块内存复制到另一块内存，不产生内存碎片，但空间利用率较低。
 - *Mark-Sweep*，标记清理，从GC roots出发标记所有存活对象，然后清理所有未标记的对象，会产生内存碎片。
 - *Mark-Compact*，标记整理，标记清除后，会压缩内存，避免内存碎片。


## 内存分配

对象实例首先在 Eden 区分配，为了快速分配，JVM 采用的是一种 *bump-the-pointer* 的**线性分配**方法。分配时一般都有大块连续内存可用，此方法就是检查剩余内存是否足够，给对象分配内存，然后更新指针偏移量和初始化对象。


线性分配效率固然高，但对多线程程序来说，分配内存的操作必须是线程安全的。可以使用全局锁但会影响性能，Hotspot JVM 采用的是一种 *Thread-Local Allocation Buffers (TLABs)* 的方法，为每个线程分配一个缓冲区，当TLAB满了，再加锁去申请，在线程内部就能使用*bump-the-pointer*，进而提高分配的吞吐量。


分配内存时，一些大对象有可能直接在老年代分配，在年轻代经过几轮Minor GC存活，达到一定年龄的对象，会被提升到老年代。



 
## Hotspot JVM

Hotspot JVM 是一个高性能虚拟机，它通过即时编译和自适应优化提高性能，
逃逸分析自JDK 6u23开始支持。




JVM 采用 Tracing GC 管理堆中的对象，那么堆外的**对象引用**就可以作为GC root：

- 栈帧中局部变量或方法参数的对象引用
- 类引用类型静态成员变量
- JNI 本地方法局部变量，参数和JNI 全局引用

需要注意GC root是一组**对象引用**而不是引用对象。
 
 
 
 
 
 
 